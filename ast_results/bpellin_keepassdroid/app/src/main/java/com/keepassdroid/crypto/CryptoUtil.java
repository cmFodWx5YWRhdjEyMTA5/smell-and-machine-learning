// isComment
package com.keepassdroid.crypto;

import com.keepassdroid.stream.LEDataOutputStream;
import com.keepassdroid.stream.NullOutputStream;
import java.io.IOException;
import java.security.DigestOutputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import javax.crypto.Mac;

public class isClassOrIsInterface {

    public static byte[] isMethod(byte[] isParameter, int isParameter, int isParameter, int isParameter) {
        if (isNameExpr == isIntegerConstant)
            return new byte[isIntegerConstant];
        byte[] isVariable;
        if (isNameExpr <= isIntegerConstant) {
            isNameExpr = isMethod(isNameExpr, isNameExpr, isNameExpr);
        } else {
            isNameExpr = isMethod(isNameExpr, isNameExpr, isNameExpr);
        }
        if (isNameExpr == isNameExpr.isFieldAccessExpr) {
            return isNameExpr;
        }
        byte[] isVariable = new byte[isNameExpr];
        if (isNameExpr < isNameExpr.isFieldAccessExpr) {
            isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr, isIntegerConstant, isNameExpr);
        } else {
            int isVariable = isIntegerConstant;
            long isVariable = isIntegerConstant;
            while (isNameExpr < isNameExpr) {
                Mac isVariable;
                try {
                    isNameExpr = isNameExpr.isMethod("isStringConstant");
                } catch (NoSuchAlgorithmException isParameter) {
                    throw new RuntimeException(isNameExpr);
                }
                byte[] isVariable = isNameExpr.isMethod(isNameExpr);
                byte[] isVariable = isNameExpr.isMethod(isNameExpr);
                int isVariable = isNameExpr.isMethod(isNameExpr - isNameExpr, isNameExpr.isFieldAccessExpr);
                assert (isNameExpr > isIntegerConstant);
                isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr, isNameExpr, isNameExpr);
                isNameExpr += isNameExpr;
                isNameExpr++;
                isNameExpr.isMethod(isNameExpr, (byte) isIntegerConstant);
            }
            assert (isNameExpr == isNameExpr);
        }
        isNameExpr.isMethod(isNameExpr, (byte) isIntegerConstant);
        return isNameExpr;
    }

    public static byte[] isMethod(byte[] isParameter) {
        return isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr);
    }

    public static byte[] isMethod(byte[] isParameter, int isParameter, int isParameter) {
        return isMethod("isStringConstant", isNameExpr, isNameExpr, isNameExpr);
    }

    public static byte[] isMethod(byte[] isParameter) {
        return isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr);
    }

    public static byte[] isMethod(byte[] isParameter, int isParameter, int isParameter) {
        return isMethod("isStringConstant", isNameExpr, isNameExpr, isNameExpr);
    }

    public static byte[] isMethod(String isParameter, byte[] isParameter, int isParameter, int isParameter) {
        MessageDigest isVariable;
        try {
            isNameExpr = isNameExpr.isMethod(isNameExpr);
        } catch (NoSuchAlgorithmException isParameter) {
            throw new RuntimeException(isNameExpr);
        }
        NullOutputStream isVariable = new NullOutputStream();
        DigestOutputStream isVariable = new DigestOutputStream(isNameExpr, isNameExpr);
        try {
            isNameExpr.isMethod(isNameExpr, isNameExpr, isNameExpr);
            isNameExpr.isMethod();
        } catch (IOException isParameter) {
            throw new RuntimeException(isNameExpr);
        }
        return isNameExpr.isMethod();
    }
}
