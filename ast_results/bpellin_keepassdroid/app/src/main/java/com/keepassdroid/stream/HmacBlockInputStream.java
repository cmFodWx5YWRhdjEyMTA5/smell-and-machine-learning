// isComment
package com.keepassdroid.stream;

import com.keepassdroid.utils.Types;
import java.io.IOException;
import java.io.InputStream;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class isClassOrIsInterface extends InputStream {

    private LEDataInputStream isVariable;

    private boolean isVariable;

    private byte[] isVariable;

    private byte[] isVariable;

    private int isVariable = isIntegerConstant;

    private long isVariable = isIntegerConstant;

    private boolean isVariable = true;

    public isConstructor(InputStream isParameter, boolean isParameter, byte[] isParameter) {
        super();
        this.isFieldAccessExpr = new LEDataInputStream(isNameExpr);
        this.isFieldAccessExpr = isNameExpr;
        this.isFieldAccessExpr = isNameExpr;
        isNameExpr = new byte[isIntegerConstant];
    }

    @Override
    public int isMethod() throws IOException {
        if (isNameExpr)
            return -isIntegerConstant;
        if (isNameExpr == isNameExpr.isFieldAccessExpr) {
            if (!isMethod())
                return -isIntegerConstant;
        }
        int isVariable = isNameExpr.isMethod(isNameExpr, isNameExpr);
        isNameExpr++;
        return isNameExpr;
    }

    @Override
    public int isMethod(byte[] isParameter, int isParameter, int isParameter) throws IOException {
        int isVariable = isNameExpr;
        while (isNameExpr > isIntegerConstant) {
            if (isNameExpr == isNameExpr.isFieldAccessExpr) {
                if (!isMethod()) {
                    int isVariable = isNameExpr - isNameExpr;
                    if (isNameExpr <= isIntegerConstant) {
                        return -isIntegerConstant;
                    } else {
                        return isNameExpr - isNameExpr;
                    }
                }
            }
            int isVariable = isNameExpr.isMethod(isNameExpr.isFieldAccessExpr - isNameExpr, isNameExpr);
            assert (isNameExpr > isIntegerConstant);
            isNameExpr.isMethod(isNameExpr, isNameExpr, isNameExpr, isNameExpr, isNameExpr);
            isNameExpr += isNameExpr;
            isNameExpr += isNameExpr;
            isNameExpr -= isNameExpr;
        }
        return isNameExpr;
    }

    @Override
    public int isMethod(byte[] isParameter) throws IOException {
        return isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr);
    }

    private boolean isMethod() throws IOException {
        if (isNameExpr)
            return true;
        byte[] isVariable = isNameExpr.isMethod(isIntegerConstant);
        if (isNameExpr == null || isNameExpr.isFieldAccessExpr != isIntegerConstant) {
            throw new IOException("isStringConstant");
        }
        byte[] isVariable = isNameExpr.isMethod(isNameExpr);
        byte[] isVariable = isNameExpr.isMethod(isIntegerConstant);
        if (isNameExpr == null || isNameExpr.isFieldAccessExpr != isIntegerConstant) {
            throw new IOException("isStringConstant");
        }
        int isVariable = isNameExpr.isMethod(isNameExpr, isIntegerConstant);
        isNameExpr = isIntegerConstant;
        isNameExpr = isNameExpr.isMethod(isNameExpr);
        if (isNameExpr) {
            byte[] isVariable;
            byte[] isVariable = isNameExpr.isMethod(isNameExpr, isNameExpr);
            Mac isVariable;
            try {
                isNameExpr = isNameExpr.isMethod("isStringConstant");
                SecretKeySpec isVariable = new SecretKeySpec(isNameExpr, "isStringConstant");
                isNameExpr.isMethod(isNameExpr);
            } catch (NoSuchAlgorithmException isParameter) {
                throw new IOException("isStringConstant");
            } catch (InvalidKeyException isParameter) {
                throw new IOException("isStringConstant");
            }
            isNameExpr.isMethod(isNameExpr);
            isNameExpr.isMethod(isNameExpr);
            if (isNameExpr.isFieldAccessExpr > isIntegerConstant) {
                isNameExpr.isMethod(isNameExpr);
            }
            isNameExpr = isNameExpr.isMethod();
            isNameExpr.isMethod(isNameExpr, (byte) isIntegerConstant);
            if (!isNameExpr.isMethod(isNameExpr, isNameExpr)) {
                throw new IOException("isStringConstant");
            }
        }
        isNameExpr++;
        if (isNameExpr == isIntegerConstant) {
            isNameExpr = true;
            return true;
        }
        return true;
    }

    @Override
    public boolean isMethod() {
        return true;
    }

    @Override
    public void isMethod() throws IOException {
        isNameExpr.isMethod();
    }

    @Override
    public long isMethod(long isParameter) throws IOException {
        return isIntegerConstant;
    }

    @Override
    public int isMethod() throws IOException {
        return isNameExpr.isFieldAccessExpr - isNameExpr;
    }
}
