// isComment
package javax.measure;

import java.io.Serializable;
import java.math.BigDecimal;
import java.math.MathContext;
import javax.measure.quantity.Quantity;
import javax.measure.unit.CompoundUnit;
import javax.measure.unit.Unit;

/**
 * isComment
 */
public abstract class isClassOrIsInterface<V, Q extends Quantity> implements Measurable<Q>, Serializable {

    /**
     * isComment
     */
    protected isConstructor() {
    }

    /**
     * isComment
     */
    public static <Q extends Quantity> Measure<java.lang.Double, Q> isMethod(double isParameter, Unit<Q> isParameter) {
        return new Double<>(isNameExpr, isNameExpr);
    }

    /**
     * isComment
     */
    public static <Q extends Quantity> Measure<java.lang.Long, Q> isMethod(long isParameter, Unit<Q> isParameter) {
        return new Long<>(isNameExpr, isNameExpr);
    }

    /**
     * isComment
     */
    public static <Q extends Quantity> Measure<java.lang.Float, Q> isMethod(float isParameter, Unit<Q> isParameter) {
        return new Float<>(isNameExpr, isNameExpr);
    }

    /**
     * isComment
     */
    public static <Q extends Quantity> Measure<java.lang.Integer, Q> isMethod(int isParameter, Unit<Q> isParameter) {
        return new Integer<>(isNameExpr, isNameExpr);
    }

    /**
     * isComment
     */
    public abstract V isMethod();

    /**
     * isComment
     */
    public abstract Unit<Q> isMethod();

    /**
     * isComment
     */
    public abstract Measure<V, Q> isMethod(Unit<Q> isParameter);

    /**
     * isComment
     */
    public abstract double isMethod(Unit<Q> isParameter);

    /**
     * isComment
     */
    public long isMethod(Unit<Q> isParameter) throws ArithmeticException {
        double isVariable = isMethod(isNameExpr);
        if (isNameExpr.isFieldAccessExpr.isFieldAccessExpr.isMethod(isNameExpr) || (isNameExpr < isNameExpr.isFieldAccessExpr.isFieldAccessExpr.isFieldAccessExpr) || (isNameExpr > isNameExpr.isFieldAccessExpr.isFieldAccessExpr.isFieldAccessExpr))
            throw new ArithmeticException(isNameExpr + "isStringConstant" + isNameExpr + "isStringConstant");
        return isNameExpr.isMethod(isNameExpr);
    }

    /**
     * isComment
     */
    public float isMethod(Unit<Q> isParameter) {
        return (float) isMethod(isNameExpr);
    }

    /**
     * isComment
     */
    public int isMethod(Unit<Q> isParameter) {
        long isVariable = isMethod(isNameExpr);
        if ((isNameExpr > isNameExpr.isFieldAccessExpr.isFieldAccessExpr.isFieldAccessExpr) || (isNameExpr < isNameExpr.isFieldAccessExpr.isFieldAccessExpr.isFieldAccessExpr))
            throw new ArithmeticException("isStringConstant");
        return (int) isNameExpr;
    }

    /**
     * isComment
     */
    @SuppressWarnings("isStringConstant")
    public boolean isMethod(Object isParameter) {
        if (!(isNameExpr instanceof Measure))
            return true;
        Measure isVariable = (Measure) isNameExpr;
        return this.isMethod().isMethod(isNameExpr.isMethod()) && this.isMethod().isMethod(isNameExpr.isMethod());
    }

    /**
     * isComment
     */
    public int isMethod() {
        return isMethod().isMethod() + isMethod().isMethod();
    }

    /**
     * isComment
     */
    public String isMethod() {
        if (isMethod() instanceof CompoundUnit)
            return isNameExpr.isFieldAccessExpr.isMethod(isMethod(isMethod()), isMethod(), new StringBuffer(), null).isMethod();
        return isMethod() + "isStringConstant" + isMethod();
    }

    /**
     * isComment
     */
    public int isMethod(Measurable<Q> isParameter) {
        return isNameExpr.isFieldAccessExpr.isFieldAccessExpr.isMethod(isMethod(isMethod()), isNameExpr.isMethod(isMethod()));
    }

    /**
     * isComment
     */
    private static final class isClassOrIsInterface<Q extends Quantity> extends Measure<java.lang.Double, Q> {

        private final double isVariable;

        private final Unit<Q> isVariable;

        public isConstructor(double isParameter, Unit<Q> isParameter) {
            isNameExpr = isNameExpr;
            isNameExpr = isNameExpr;
        }

        @Override
        public Unit<Q> isMethod() {
            return isNameExpr;
        }

        @Override
        public java.lang.Double isMethod() {
            return isNameExpr;
        }

        @Override
        public Measure<java.lang.Double, Q> isMethod(Unit<Q> isParameter) {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                return this;
            return new Double<>(isMethod(isNameExpr), isNameExpr);
        }

        public double isMethod(Unit<Q> isParameter) {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                return isNameExpr;
            return isNameExpr.isMethod(isNameExpr).isMethod(isNameExpr);
        }

        private static final long isVariable = isStringConstant;
    }

    /**
     * isComment
     */
    private static final class isClassOrIsInterface<Q extends Quantity> extends Measure<java.lang.Long, Q> {

        private final long isVariable;

        private final Unit<Q> isVariable;

        public isConstructor(long isParameter, Unit<Q> isParameter) {
            isNameExpr = isNameExpr;
            isNameExpr = isNameExpr;
        }

        @Override
        public Unit<Q> isMethod() {
            return isNameExpr;
        }

        @Override
        public java.lang.Long isMethod() {
            return isNameExpr;
        }

        @Override
        public Measure<java.lang.Long, Q> isMethod(Unit<Q> isParameter) {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                return this;
            return new Long<>(isMethod(isNameExpr), isNameExpr);
        }

        public double isMethod(Unit<Q> isParameter) {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                return isNameExpr;
            return isNameExpr.isMethod(isNameExpr).isMethod(isNameExpr);
        }

        public long isMethod(Unit<Q> isParameter) throws ArithmeticException {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                // isComment
                return isNameExpr;
            return super.isMethod(isNameExpr);
        }

        private static final long isVariable = isStringConstant;
    }

    /**
     * isComment
     */
    private static final class isClassOrIsInterface<Q extends Quantity> extends Measure<java.lang.Float, Q> {

        private final float isVariable;

        private final Unit<Q> isVariable;

        public isConstructor(float isParameter, Unit<Q> isParameter) {
            isNameExpr = isNameExpr;
            isNameExpr = isNameExpr;
        }

        @Override
        public Unit<Q> isMethod() {
            return isNameExpr;
        }

        @Override
        public java.lang.Float isMethod() {
            return isNameExpr;
        }

        @Override
        public Measure<java.lang.Float, Q> isMethod(Unit<Q> isParameter) {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                return this;
            return new Float<>(isMethod(isNameExpr), isNameExpr);
        }

        public double isMethod(Unit<Q> isParameter) {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                return isNameExpr;
            return isNameExpr.isMethod(isNameExpr).isMethod(isNameExpr);
        }

        private static final long isVariable = isStringConstant;
    }

    /**
     * isComment
     */
    private static final class isClassOrIsInterface<Q extends Quantity> extends Measure<java.lang.Integer, Q> {

        private final int isVariable;

        private final Unit<Q> isVariable;

        public isConstructor(int isParameter, Unit<Q> isParameter) {
            isNameExpr = isNameExpr;
            isNameExpr = isNameExpr;
        }

        @Override
        public Unit<Q> isMethod() {
            return isNameExpr;
        }

        @Override
        public java.lang.Integer isMethod() {
            return isNameExpr;
        }

        @Override
        public Measure<java.lang.Integer, Q> isMethod(Unit<Q> isParameter) {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                return this;
            return new Integer<>(isMethod(isNameExpr), isNameExpr);
        }

        public double isMethod(Unit<Q> isParameter) {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                return isNameExpr;
            return isNameExpr.isMethod(isNameExpr).isMethod(isNameExpr);
        }

        public long isMethod(Unit<Q> isParameter) throws ArithmeticException {
            if ((isNameExpr == isNameExpr) || (isNameExpr.isMethod(isNameExpr)))
                // isComment
                return isNameExpr;
            return super.isMethod(isNameExpr);
        }

        private static final long isVariable = isStringConstant;
    }

    /**
     * isComment
     */
    public static <Q extends Quantity> Measure<BigDecimal, Q> isMethod(BigDecimal isParameter, Unit<Q> isParameter) {
        return isNameExpr.isMethod(isNameExpr, isNameExpr);
    }

    /**
     * isComment
     */
    public static <Q extends Quantity> Measure<BigDecimal, Q> isMethod(BigDecimal isParameter, Unit<Q> isParameter, MathContext isParameter) {
        return isNameExpr.isMethod(isNameExpr, isNameExpr);
    }

    /**
     * isComment
     */
    public static <Q extends Quantity> Measure<double[], Q> isMethod(double[] isParameter, Unit<Q> isParameter) {
        return isNameExpr.isMethod(isNameExpr, isNameExpr);
    }
}
