// isComment
package jcifs.ntlmssp;

import jcifs.Config;

/**
 * isComment
 */
public abstract class isClassOrIsInterface implements NtlmFlags {

    /**
     * isComment
     */
    protected static final byte[] isVariable = new byte[] { (byte) 'isStringConstant', (byte) 'isStringConstant', (byte) 'isStringConstant', (byte) 'isStringConstant', (byte) 'isStringConstant', (byte) 'isStringConstant', (byte) 'isStringConstant', (byte) isIntegerConstant };

    private static final String isVariable = isNameExpr.isFieldAccessExpr;

    protected static final String isVariable = "isStringConstant";

    private int isVariable;

    /**
     * isComment
     */
    public int isMethod() {
        return isNameExpr;
    }

    /**
     * isComment
     */
    public void isMethod(int isParameter) {
        this.isFieldAccessExpr = isNameExpr;
    }

    /**
     * isComment
     */
    public boolean isMethod(int isParameter) {
        return (isMethod() & isNameExpr) != isIntegerConstant;
    }

    /**
     * isComment
     */
    public void isMethod(int isParameter, boolean isParameter) {
        isMethod(isNameExpr ? (isMethod() | isNameExpr) : (isMethod() & (isIntegerConstant ^ isNameExpr)));
    }

    static int isMethod(byte[] isParameter, int isParameter) {
        return (isNameExpr[isNameExpr] & isIntegerConstant) | ((isNameExpr[isNameExpr + isIntegerConstant] & isIntegerConstant) << isIntegerConstant) | ((isNameExpr[isNameExpr + isIntegerConstant] & isIntegerConstant) << isIntegerConstant) | ((isNameExpr[isNameExpr + isIntegerConstant] & isIntegerConstant) << isIntegerConstant);
    }

    static int isMethod(byte[] isParameter, int isParameter) {
        return (isNameExpr[isNameExpr] & isIntegerConstant) | ((isNameExpr[isNameExpr + isIntegerConstant] & isIntegerConstant) << isIntegerConstant);
    }

    static byte[] isMethod(byte[] isParameter, int isParameter) {
        int isVariable = isMethod(isNameExpr, isNameExpr);
        int isVariable = isMethod(isNameExpr, isNameExpr + isIntegerConstant);
        byte[] isVariable = new byte[isNameExpr];
        isNameExpr.isMethod(isNameExpr, isNameExpr, isNameExpr, isIntegerConstant, isNameExpr);
        return isNameExpr;
    }

    static void isMethod(byte[] isParameter, int isParameter, int isParameter) {
        isNameExpr[isNameExpr] = (byte) (isNameExpr & isIntegerConstant);
        isNameExpr[isNameExpr + isIntegerConstant] = (byte) (isNameExpr >> isIntegerConstant & isIntegerConstant);
        isNameExpr[isNameExpr + isIntegerConstant] = (byte) (isNameExpr >> isIntegerConstant & isIntegerConstant);
        isNameExpr[isNameExpr + isIntegerConstant] = (byte) (isNameExpr >> isIntegerConstant & isIntegerConstant);
    }

    static void isMethod(byte[] isParameter, int isParameter, int isParameter) {
        isNameExpr[isNameExpr] = (byte) (isNameExpr & isIntegerConstant);
        isNameExpr[isNameExpr + isIntegerConstant] = (byte) (isNameExpr >> isIntegerConstant & isIntegerConstant);
    }

    static void isMethod(byte[] isParameter, int isParameter, int isParameter, byte[] isParameter) {
        int isVariable = (isNameExpr != null) ? isNameExpr.isFieldAccessExpr : isIntegerConstant;
        if (isNameExpr == isIntegerConstant)
            return;
        isMethod(isNameExpr, isNameExpr, isNameExpr);
        isMethod(isNameExpr, isNameExpr + isIntegerConstant, isNameExpr);
        isMethod(isNameExpr, isNameExpr + isIntegerConstant, isNameExpr);
        isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr, isNameExpr, isNameExpr);
    }

    static String isMethod() {
        return isNameExpr;
    }

    /**
     * isComment
     */
    public abstract byte[] isMethod();
}
