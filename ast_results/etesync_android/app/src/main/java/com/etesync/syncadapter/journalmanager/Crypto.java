// isComment
package com.etesync.syncadapter.journalmanager;

import android.support.annotation.NonNull;
import com.etesync.syncadapter.App;
import com.etesync.syncadapter.journalmanager.util.ByteUtil;
import com.etesync.syncadapter.utils.Base64;
import org.apache.commons.codec.Charsets;
import org.apache.commons.lang3.ArrayUtils;
import org.spongycastle.asn1.pkcs.PrivateKeyInfo;
import org.spongycastle.asn1.x509.SubjectPublicKeyInfo;
import org.spongycastle.crypto.AsymmetricBlockCipher;
import org.spongycastle.crypto.AsymmetricCipherKeyPair;
import org.spongycastle.crypto.BufferedBlockCipher;
import org.spongycastle.crypto.CipherParameters;
import org.spongycastle.crypto.InvalidCipherTextException;
import org.spongycastle.crypto.digests.SHA256Digest;
import org.spongycastle.crypto.encodings.OAEPEncoding;
import org.spongycastle.crypto.engines.AESEngine;
import org.spongycastle.crypto.engines.RSAEngine;
import org.spongycastle.crypto.generators.RSAKeyPairGenerator;
import org.spongycastle.crypto.generators.SCrypt;
import org.spongycastle.crypto.macs.HMac;
import org.spongycastle.crypto.modes.CBCBlockCipher;
import org.spongycastle.crypto.paddings.BlockCipherPadding;
import org.spongycastle.crypto.paddings.PKCS7Padding;
import org.spongycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.spongycastle.crypto.params.KeyParameter;
import org.spongycastle.crypto.params.ParametersWithIV;
import org.spongycastle.crypto.params.RSAKeyGenerationParameters;
import org.spongycastle.crypto.util.PrivateKeyFactory;
import org.spongycastle.crypto.util.PrivateKeyInfoFactory;
import org.spongycastle.crypto.util.PublicKeyFactory;
import org.spongycastle.crypto.util.SubjectPublicKeyInfoFactory;
import org.spongycastle.util.encoders.Hex;
import java.io.IOException;
import java.io.Serializable;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Locale;

public class isClassOrIsInterface {

    public static String isMethod(String isParameter, String isParameter) {
        final int isVariable = isIntegerConstant;
        return isNameExpr.isMethod(isNameExpr.isMethod(isNameExpr.isMethod(isNameExpr.isFieldAccessExpr), isNameExpr.isMethod(isNameExpr.isFieldAccessExpr), isIntegerConstant, isIntegerConstant, isIntegerConstant, isNameExpr), isNameExpr.isFieldAccessExpr);
    }

    public static AsymmetricKeyPair isMethod() {
        RSAKeyPairGenerator isVariable = new RSAKeyPairGenerator();
        isNameExpr.isMethod(new RSAKeyGenerationParameters(isNameExpr.isMethod(isIntegerConstant), new SecureRandom(), isIntegerConstant, isIntegerConstant));
        AsymmetricCipherKeyPair isVariable = isNameExpr.isMethod();
        try {
            PrivateKeyInfo isVariable = isNameExpr.isMethod(isNameExpr.isMethod());
            SubjectPublicKeyInfo isVariable = isNameExpr.isMethod(isNameExpr.isMethod());
            return new AsymmetricKeyPair(isNameExpr.isMethod(), isNameExpr.isMethod());
        } catch (IOException isParameter) {
            isNameExpr.isMethod();
        }
        return null;
    }

    public static class isClassOrIsInterface implements Serializable {

        private final byte[] isVariable;

        private final byte[] isVariable;

        public byte[] isMethod() {
            return isNameExpr;
        }

        public byte[] isMethod() {
            return isNameExpr;
        }

        public isConstructor(final byte[] isParameter, final byte[] isParameter) {
            this.isFieldAccessExpr = isNameExpr;
            this.isFieldAccessExpr = isNameExpr;
        }
    }

    public static class isClassOrIsInterface {

        private final AsymmetricKeyPair isVariable;

        public isConstructor(AsymmetricKeyPair isParameter) {
            this.isFieldAccessExpr = isNameExpr;
        }

        public byte[] isMethod(byte[] isParameter, byte[] isParameter) {
            AsymmetricBlockCipher isVariable = new RSAEngine();
            isNameExpr = new OAEPEncoding(isNameExpr);
            try {
                isNameExpr.isMethod(true, isNameExpr.isMethod(isNameExpr));
                return isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr);
            } catch (IOException isParameter) {
                isNameExpr.isMethod();
            } catch (InvalidCipherTextException isParameter) {
                isNameExpr.isMethod();
                isNameExpr.isFieldAccessExpr.isMethod("isStringConstant" + isNameExpr.isMethod(isNameExpr, isNameExpr.isFieldAccessExpr));
            }
            return null;
        }

        public byte[] isMethod(byte[] isParameter) {
            AsymmetricBlockCipher isVariable = new RSAEngine();
            isNameExpr = new OAEPEncoding(isNameExpr);
            try {
                isNameExpr.isMethod(true, isNameExpr.isMethod(isNameExpr.isMethod()));
                return isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr);
            } catch (IOException isParameter) {
                isNameExpr.isMethod();
            } catch (InvalidCipherTextException isParameter) {
                isNameExpr.isMethod();
                isNameExpr.isFieldAccessExpr.isMethod("isStringConstant" + isNameExpr.isMethod(isNameExpr, isNameExpr.isFieldAccessExpr));
            }
            return null;
        }

        public static byte[] isMethod(byte[] isParameter) {
            return isMethod(isNameExpr);
        }

        public static String isMethod(byte[] isParameter) {
            byte[] isVariable = isNameExpr.isFieldAccessExpr.isMethod(isNameExpr);
            String isVariable = "isStringConstant";
            String isVariable = isMethod(isNameExpr, isIntegerConstant) + isNameExpr + isMethod(isNameExpr, isIntegerConstant) + isNameExpr + isMethod(isNameExpr, isIntegerConstant) + isNameExpr + isMethod(isNameExpr, isIntegerConstant) + "isStringConstant" + isMethod(isNameExpr, isIntegerConstant) + isNameExpr + isMethod(isNameExpr, isIntegerConstant) + isNameExpr + isMethod(isNameExpr, isIntegerConstant) + isNameExpr + isMethod(isNameExpr, isIntegerConstant);
            return isNameExpr.isMethod();
        }

        private static String isMethod(byte[] isParameter, int isParameter) {
            long isVariable = isNameExpr.isMethod(isNameExpr, isNameExpr) % isIntegerConstant;
            return isNameExpr.isMethod(isNameExpr.isMethod(), "isStringConstant", isNameExpr);
        }
    }

    public static class isClassOrIsInterface {

        // isComment
        static final int isVariable = isIntegerConstant / isIntegerConstant;

        private SecureRandom isVariable = null;

        private final byte isVariable;

        private byte[] isVariable;

        private byte[] isVariable;

        private byte[] isVariable;

        public byte isMethod() {
            return isNameExpr;
        }

        private void isMethod(byte[] isParameter) {
            isNameExpr = isMethod("isStringConstant".isMethod(isNameExpr.isFieldAccessExpr), isNameExpr);
            isNameExpr = isMethod("isStringConstant".isMethod(isNameExpr.isFieldAccessExpr), isNameExpr);
        }

        public isConstructor(int isParameter, AsymmetricKeyPair isParameter, byte[] isParameter) {
            Crypto.AsymmetricCryptoManager isVariable = new Crypto.AsymmetricCryptoManager(isNameExpr);
            isNameExpr = isNameExpr.isMethod(isNameExpr);
            this.isFieldAccessExpr = (byte) isNameExpr;
            isMethod(isNameExpr);
        }

        public isConstructor(int isParameter, @NonNull String isParameter, @NonNull String isParameter) throws Exceptions.IntegrityException, Exceptions.VersionTooNewException {
            if (isNameExpr > isNameExpr.isFieldAccessExpr) {
                throw new Exceptions.IntegrityException("isStringConstant");
            } else if (isNameExpr > isNameExpr.isFieldAccessExpr) {
                throw new Exceptions.VersionTooNewException("isStringConstant" + isNameExpr.isMethod(isNameExpr));
            } else if (isNameExpr == isIntegerConstant) {
                isNameExpr = isNameExpr.isMethod(isNameExpr, isNameExpr.isFieldAccessExpr);
            } else {
                isNameExpr = isMethod(isNameExpr.isMethod(isNameExpr.isFieldAccessExpr), isNameExpr.isMethod(isNameExpr, isNameExpr.isFieldAccessExpr));
            }
            this.isFieldAccessExpr = (byte) isNameExpr;
            isMethod(isNameExpr);
        }

        // isComment
        private static final int isVariable = isIntegerConstant;

        private BufferedBlockCipher isMethod(byte[] isParameter, boolean isParameter) {
            KeyParameter isVariable = new KeyParameter(isNameExpr);
            CipherParameters isVariable = new ParametersWithIV(isNameExpr, isNameExpr);
            BlockCipherPadding isVariable = new PKCS7Padding();
            BufferedBlockCipher isVariable = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESEngine()), isNameExpr);
            isNameExpr.isMethod();
            isNameExpr.isMethod(isNameExpr, isNameExpr);
            return isNameExpr;
        }

        byte[] isMethod(byte[] isParameter) {
            byte[] isVariable = isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr);
            byte[] isVariable = isNameExpr.isMethod(isNameExpr, isNameExpr, isNameExpr.isFieldAccessExpr);
            BufferedBlockCipher isVariable = isMethod(isNameExpr, true);
            byte[] isVariable = new byte[isNameExpr.isMethod(isNameExpr.isFieldAccessExpr)];
            int isVariable = isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr, isNameExpr, isIntegerConstant);
            try {
                isNameExpr += isNameExpr.isMethod(isNameExpr, isNameExpr);
            } catch (InvalidCipherTextException isParameter) {
                isNameExpr.isMethod();
                isNameExpr.isFieldAccessExpr.isMethod("isStringConstant" + isNameExpr.isMethod(isNameExpr, isNameExpr.isFieldAccessExpr));
                return null;
            }
            // isComment
            byte[] isVariable = new byte[isNameExpr];
            isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr, isIntegerConstant, isNameExpr);
            return isNameExpr;
        }

        byte[] isMethod(byte[] isParameter) {
            byte[] isVariable = new byte[isNameExpr];
            isMethod().isMethod(isNameExpr);
            BufferedBlockCipher isVariable = isMethod(isNameExpr, true);
            byte[] isVariable = new byte[isNameExpr.isMethod(isNameExpr.isFieldAccessExpr) + isNameExpr];
            isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr);
            int isVariable = isNameExpr.isFieldAccessExpr + isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr, isNameExpr, isNameExpr.isFieldAccessExpr);
            try {
                isNameExpr.isMethod(isNameExpr, isNameExpr);
            } catch (InvalidCipherTextException isParameter) {
                isNameExpr.isFieldAccessExpr.isMethod("isStringConstant" + isNameExpr.isMethod(isNameExpr, isNameExpr.isFieldAccessExpr));
                isNameExpr.isMethod();
                return null;
            }
            return isNameExpr;
        }

        byte[] isMethod(byte[] isParameter) {
            if (isNameExpr == isIntegerConstant) {
                return isMethod(isNameExpr, isNameExpr);
            } else {
                // isComment
                return isMethod(isNameExpr, isNameExpr.isMethod(isNameExpr, isNameExpr));
            }
        }

        private SecureRandom isMethod() {
            if (isNameExpr == null) {
                isNameExpr = new SecureRandom();
            }
            return isNameExpr;
        }

        private static byte[] isMethod(byte[] isParameter, byte[] isParameter) {
            HMac isVariable = new HMac(new SHA256Digest());
            KeyParameter isVariable = new KeyParameter(isNameExpr);
            byte[] isVariable = new byte[isNameExpr.isMethod()];
            isNameExpr.isMethod(isNameExpr);
            isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr);
            isNameExpr.isMethod(isNameExpr, isIntegerConstant);
            return isNameExpr;
        }

        public byte[] isMethod(AsymmetricKeyPair isParameter, byte[] isParameter) {
            AsymmetricCryptoManager isVariable = new AsymmetricCryptoManager(isNameExpr);
            return isNameExpr.isMethod(isNameExpr, isNameExpr);
        }
    }

    static String isMethod(String isParameter) {
        return isMethod(isMethod(isNameExpr.isMethod(isNameExpr.isFieldAccessExpr)));
    }

    private static byte[] isMethod(byte[] isParameter) {
        SHA256Digest isVariable = new SHA256Digest();
        isNameExpr.isMethod(isNameExpr, isIntegerConstant, isNameExpr.isFieldAccessExpr);
        byte[] isVariable = new byte[isNameExpr.isMethod()];
        isNameExpr.isMethod(isNameExpr, isIntegerConstant);
        return isNameExpr;
    }

    static String isMethod(byte[] isParameter) {
        return isNameExpr.isMethod(isNameExpr).isMethod();
    }
}
