// isComment
package org.geometerplus.zlibrary.text.hyphenation;

import java.util.List;
import org.geometerplus.zlibrary.text.view.ZLTextWord;

public abstract class isClassOrIsInterface {

    private static ZLTextHyphenator isVariable;

    public static ZLTextHyphenator isMethod() {
        if (isNameExpr == null) {
            isNameExpr = new ZLTextTeXHyphenator();
        }
        return isNameExpr;
    }

    public static void isMethod() {
        if (isNameExpr != null) {
            isNameExpr.isMethod();
            isNameExpr = null;
        }
    }

    protected isConstructor() {
    }

    public abstract List<String> isMethod();

    public abstract void isMethod(final String isParameter);

    public abstract void isMethod();

    public ZLTextHyphenationInfo isMethod(final ZLTextWord isParameter) {
        final int isVariable = isNameExpr.isFieldAccessExpr;
        final boolean[] isVariable = new boolean[isNameExpr];
        final char[] isVariable = new char[isNameExpr + isIntegerConstant];
        final char[] isVariable = isNameExpr.isFieldAccessExpr;
        isNameExpr[isIntegerConstant] = 'isStringConstant';
        for (int isVariable = isIntegerConstant, isVariable = isNameExpr.isFieldAccessExpr; isNameExpr < isNameExpr; ++isNameExpr, ++isNameExpr) {
            char isVariable = isNameExpr[isNameExpr];
            if (isNameExpr == 'isStringConstant' || isNameExpr == 'isStringConstant' || isNameExpr.isMethod(isNameExpr)) {
                isNameExpr[isNameExpr] = true;
                isNameExpr[isNameExpr + isIntegerConstant] = isNameExpr.isMethod(isNameExpr);
            } else {
                isNameExpr[isNameExpr + isIntegerConstant] = 'isStringConstant';
            }
        }
        isNameExpr[isNameExpr + isIntegerConstant] = 'isStringConstant';
        final ZLTextHyphenationInfo isVariable = new ZLTextHyphenationInfo(isNameExpr + isIntegerConstant);
        final boolean[] isVariable = isNameExpr.isFieldAccessExpr;
        isMethod(isNameExpr, isNameExpr, isNameExpr + isIntegerConstant);
        for (int isVariable = isIntegerConstant, isVariable = isNameExpr.isFieldAccessExpr - isIntegerConstant; isNameExpr <= isNameExpr; ++isNameExpr, ++isNameExpr) {
            if ((isNameExpr < isIntegerConstant) || (isNameExpr > isNameExpr - isIntegerConstant)) {
                isNameExpr[isNameExpr] = true;
            } else {
                switch(isNameExpr[isNameExpr]) {
                    case // isComment
                    (char) isIntegerConstant:
                        isNameExpr[isNameExpr] = true;
                        break;
                    case 'isStringConstant':
                        isNameExpr[isNameExpr] = (isNameExpr >= isIntegerConstant) && isNameExpr[isNameExpr - isIntegerConstant] && isNameExpr[isNameExpr - isIntegerConstant] && isNameExpr[isNameExpr] && isNameExpr[isNameExpr + isIntegerConstant];
                        break;
                    default:
                        isNameExpr[isNameExpr] = isNameExpr[isNameExpr] && isNameExpr[isNameExpr - isIntegerConstant] && isNameExpr[isNameExpr - isIntegerConstant] && isNameExpr[isNameExpr] && isNameExpr[isNameExpr + isIntegerConstant];
                        break;
                }
            }
        }
        return isNameExpr;
    }

    protected abstract void isMethod(char[] isParameter, boolean[] isParameter, int isParameter);
}
