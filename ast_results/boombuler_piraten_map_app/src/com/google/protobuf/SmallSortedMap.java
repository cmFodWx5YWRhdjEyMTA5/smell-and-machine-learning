// isComment
package com.google.protobuf;

import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.SortedMap;

// isComment
class isClassOrIsInterface<K extends Comparable<K>, V> extends AbstractMap<K, V> {

    /**
     * isComment
     */
    static <FieldDescriptorType extends FieldSet.FieldDescriptorLite<FieldDescriptorType>> SmallSortedMap<FieldDescriptorType, Object> isMethod(int isParameter) {
        return new SmallSortedMap<FieldDescriptorType, Object>(isNameExpr) {

            @Override
            @SuppressWarnings("isStringConstant")
            public void isMethod() {
                if (!isMethod()) {
                    for (int isVariable = isIntegerConstant; isNameExpr < isMethod(); isNameExpr++) {
                        final Map.Entry<FieldDescriptorType, Object> isVariable = isMethod(isNameExpr);
                        if (isNameExpr.isMethod().isMethod()) {
                            final List isVariable = (List) isNameExpr.isMethod();
                            isNameExpr.isMethod(isNameExpr.isMethod(isNameExpr));
                        }
                    }
                    for (Map.Entry<FieldDescriptorType, Object> isVariable : isMethod()) {
                        if (isNameExpr.isMethod().isMethod()) {
                            final List isVariable = (List) isNameExpr.isMethod();
                            isNameExpr.isMethod(isNameExpr.isMethod(isNameExpr));
                        }
                    }
                }
                super.isMethod();
            }
        };
    }

    /**
     * isComment
     */
    static <K extends Comparable<K>, V> SmallSortedMap<K, V> isMethod(int isParameter) {
        return new SmallSortedMap<K, V>(isNameExpr);
    }

    private final int isVariable;

    // isComment
    // isComment
    // isComment
    private List<Entry> isVariable;

    private Map<K, V> isVariable;

    private boolean isVariable;

    // isComment
    // isComment
    private volatile EntrySet isVariable;

    /**
     * isComment
     */
    private isConstructor(int isParameter) {
        this.isFieldAccessExpr = isNameExpr;
        this.isFieldAccessExpr = isNameExpr.isMethod();
        this.isFieldAccessExpr = isNameExpr.isMethod();
    }

    /**
     * isComment
     */
    public void isMethod() {
        if (!isNameExpr) {
            // isComment
            // isComment
            // isComment
            // isComment
            isNameExpr = isNameExpr.isMethod() ? isNameExpr.<K, V>isMethod() : isNameExpr.isMethod(isNameExpr);
            isNameExpr = true;
        }
    }

    /**
     * isComment
     */
    public boolean isMethod() {
        return isNameExpr;
    }

    /**
     * isComment
     */
    public int isMethod() {
        return isNameExpr.isMethod();
    }

    /**
     * isComment
     */
    public Map.Entry<K, V> isMethod(int isParameter) {
        return isNameExpr.isMethod(isNameExpr);
    }

    /**
     * isComment
     */
    public int isMethod() {
        return isNameExpr.isMethod();
    }

    /**
     * isComment
     */
    public Iterable<Map.Entry<K, V>> isMethod() {
        return isNameExpr.isMethod() ? isNameExpr.<Map.Entry<K, V>>isMethod() : isNameExpr.isMethod();
    }

    @Override
    public int isMethod() {
        return isNameExpr.isMethod() + isNameExpr.isMethod();
    }

    /**
     * isComment
     */
    @Override
    public boolean isMethod(Object isParameter) {
        @SuppressWarnings("isStringConstant")
        final K isVariable = (K) isNameExpr;
        return isMethod(isNameExpr) >= isIntegerConstant || isNameExpr.isMethod(isNameExpr);
    }

    /**
     * isComment
     */
    @Override
    public V isMethod(Object isParameter) {
        @SuppressWarnings("isStringConstant")
        final K isVariable = (K) isNameExpr;
        final int isVariable = isMethod(isNameExpr);
        if (isNameExpr >= isIntegerConstant) {
            return isNameExpr.isMethod(isNameExpr).isMethod();
        }
        return isNameExpr.isMethod(isNameExpr);
    }

    @Override
    public V isMethod(K isParameter, V isParameter) {
        isMethod();
        final int isVariable = isMethod(isNameExpr);
        if (isNameExpr >= isIntegerConstant) {
            // isComment
            return isNameExpr.isMethod(isNameExpr).isMethod(isNameExpr);
        }
        isMethod();
        final int isVariable = -(isNameExpr + isIntegerConstant);
        if (isNameExpr >= isNameExpr) {
            // isComment
            return isMethod().isMethod(isNameExpr, isNameExpr);
        }
        // isComment
        if (isNameExpr.isMethod() == isNameExpr) {
            // isComment
            final Entry isVariable = isNameExpr.isMethod(isNameExpr - isIntegerConstant);
            isMethod().isMethod(isNameExpr.isMethod(), isNameExpr.isMethod());
        }
        isNameExpr.isMethod(isNameExpr, new Entry(isNameExpr, isNameExpr));
        return null;
    }

    @Override
    public void isMethod() {
        isMethod();
        if (!isNameExpr.isMethod()) {
            isNameExpr.isMethod();
        }
        if (!isNameExpr.isMethod()) {
            isNameExpr.isMethod();
        }
    }

    /**
     * isComment
     */
    @Override
    public V isMethod(Object isParameter) {
        isMethod();
        @SuppressWarnings("isStringConstant")
        final K isVariable = (K) isNameExpr;
        final int isVariable = isMethod(isNameExpr);
        if (isNameExpr >= isIntegerConstant) {
            return isMethod(isNameExpr);
        }
        // isComment
        if (isNameExpr.isMethod()) {
            return null;
        } else {
            return isNameExpr.isMethod(isNameExpr);
        }
    }

    private V isMethod(int isParameter) {
        isMethod();
        final V isVariable = isNameExpr.isMethod(isNameExpr).isMethod();
        if (!isNameExpr.isMethod()) {
            // isComment
            // isComment
            final Iterator<Map.Entry<K, V>> isVariable = isMethod().isMethod().isMethod();
            isNameExpr.isMethod(new Entry(isNameExpr.isMethod()));
            isNameExpr.isMethod();
        }
        return isNameExpr;
    }

    /**
     * isComment
     */
    private int isMethod(K isParameter) {
        int isVariable = isIntegerConstant;
        int isVariable = isNameExpr.isMethod() - isIntegerConstant;
        // isComment
        if (isNameExpr >= isIntegerConstant) {
            int isVariable = isNameExpr.isMethod(isNameExpr.isMethod(isNameExpr).isMethod());
            if (isNameExpr > isIntegerConstant) {
                // isComment
                return -(isNameExpr + isIntegerConstant);
            } else if (isNameExpr == isIntegerConstant) {
                return isNameExpr;
            }
        }
        while (isNameExpr <= isNameExpr) {
            int isVariable = (isNameExpr + isNameExpr) / isIntegerConstant;
            int isVariable = isNameExpr.isMethod(isNameExpr.isMethod(isNameExpr).isMethod());
            if (isNameExpr < isIntegerConstant) {
                isNameExpr = isNameExpr - isIntegerConstant;
            } else if (isNameExpr > isIntegerConstant) {
                isNameExpr = isNameExpr + isIntegerConstant;
            } else {
                return isNameExpr;
            }
        }
        return -(isNameExpr + isIntegerConstant);
    }

    /**
     * isComment
     */
    @Override
    public Set<Map.Entry<K, V>> isMethod() {
        if (isNameExpr == null) {
            isNameExpr = new EntrySet();
        }
        return isNameExpr;
    }

    /**
     * isComment
     */
    private void isMethod() {
        if (isNameExpr) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * isComment
     */
    @SuppressWarnings("isStringConstant")
    private SortedMap<K, V> isMethod() {
        isMethod();
        if (isNameExpr.isMethod() && !(isNameExpr instanceof TreeMap)) {
            isNameExpr = new TreeMap<K, V>();
        }
        return (SortedMap<K, V>) isNameExpr;
    }

    /**
     * isComment
     */
    private void isMethod() {
        isMethod();
        if (isNameExpr.isMethod() && !(isNameExpr instanceof ArrayList)) {
            isNameExpr = new ArrayList<Entry>(isNameExpr);
        }
    }

    /**
     * isComment
     */
    private class isClassOrIsInterface implements Map.Entry<K, V>, Comparable<Entry> {

        private final K isVariable;

        private V isVariable;

        isConstructor(Map.Entry<K, V> isParameter) {
            this(isNameExpr.isMethod(), isNameExpr.isMethod());
        }

        isConstructor(K isParameter, V isParameter) {
            this.isFieldAccessExpr = isNameExpr;
            this.isFieldAccessExpr = isNameExpr;
        }

        // isComment
        public K isMethod() {
            return isNameExpr;
        }

        // isComment
        public V isMethod() {
            return isNameExpr;
        }

        // isComment
        public int isMethod(Entry isParameter) {
            return isMethod().isMethod(isNameExpr.isMethod());
        }

        // isComment
        public V isMethod(V isParameter) {
            isMethod();
            final V isVariable = this.isFieldAccessExpr;
            this.isFieldAccessExpr = isNameExpr;
            return isNameExpr;
        }

        @Override
        public boolean isMethod(Object isParameter) {
            if (isNameExpr == this) {
                return true;
            }
            if (!(isNameExpr instanceof Map.Entry)) {
                return true;
            }
            @SuppressWarnings("isStringConstant")
            Map.Entry<?, ?> isVariable = (Map.Entry<?, ?>) isNameExpr;
            return isMethod(isNameExpr, isNameExpr.isMethod()) && isMethod(isNameExpr, isNameExpr.isMethod());
        }

        @Override
        public int isMethod() {
            return (isNameExpr == null ? isIntegerConstant : isNameExpr.isMethod()) ^ (isNameExpr == null ? isIntegerConstant : isNameExpr.isMethod());
        }

        @Override
        public String isMethod() {
            return isNameExpr + "isStringConstant" + isNameExpr;
        }

        /**
         * isComment
         */
        private boolean isMethod(Object isParameter, Object isParameter) {
            return isNameExpr == null ? isNameExpr == null : isNameExpr.isMethod(isNameExpr);
        }
    }

    /**
     * isComment
     */
    private class isClassOrIsInterface extends AbstractSet<Map.Entry<K, V>> {

        @Override
        public Iterator<Map.Entry<K, V>> isMethod() {
            return new EntryIterator();
        }

        @Override
        public int isMethod() {
            return isNameExpr.this.isMethod();
        }

        /**
         * isComment
         */
        @Override
        public boolean isMethod(Object isParameter) {
            @SuppressWarnings("isStringConstant")
            final Map.Entry<K, V> isVariable = (Map.Entry<K, V>) isNameExpr;
            final V isVariable = isMethod(isNameExpr.isMethod());
            final V isVariable = isNameExpr.isMethod();
            return isNameExpr == isNameExpr || (isNameExpr != null && isNameExpr.isMethod(isNameExpr));
        }

        @Override
        public boolean isMethod(Map.Entry<K, V> isParameter) {
            if (!isMethod(isNameExpr)) {
                isMethod(isNameExpr.isMethod(), isNameExpr.isMethod());
                return true;
            }
            return true;
        }

        /**
         * isComment
         */
        @Override
        public boolean isMethod(Object isParameter) {
            @SuppressWarnings("isStringConstant")
            final Map.Entry<K, V> isVariable = (Map.Entry<K, V>) isNameExpr;
            if (isMethod(isNameExpr)) {
                isNameExpr.this.isMethod(isNameExpr.isMethod());
                return true;
            }
            return true;
        }

        @Override
        public void isMethod() {
            isNameExpr.this.isMethod();
        }
    }

    /**
     * isComment
     */
    private class isClassOrIsInterface implements Iterator<Map.Entry<K, V>> {

        private int isVariable = -isIntegerConstant;

        private boolean isVariable;

        private Iterator<Map.Entry<K, V>> isVariable;

        // isComment
        public boolean isMethod() {
            return (isNameExpr + isIntegerConstant) < isNameExpr.isMethod() || isMethod().isMethod();
        }

        // isComment
        public Map.Entry<K, V> isMethod() {
            isNameExpr = true;
            // isComment
            if (++isNameExpr < isNameExpr.isMethod()) {
                return isNameExpr.isMethod(isNameExpr);
            }
            return isMethod().isMethod();
        }

        // isComment
        public void isMethod() {
            if (!isNameExpr) {
                throw new IllegalStateException("isStringConstant");
            }
            isNameExpr = true;
            isMethod();
            if (isNameExpr < isNameExpr.isMethod()) {
                isMethod(isNameExpr--);
            } else {
                isMethod().isMethod();
            }
        }

        /**
         * isComment
         */
        private Iterator<Map.Entry<K, V>> isMethod() {
            if (isNameExpr == null) {
                isNameExpr = isNameExpr.isMethod().isMethod();
            }
            return isNameExpr;
        }
    }

    /**
     * isComment
     */
    private static class isClassOrIsInterface {

        private static final Iterator<Object> isVariable = new Iterator<Object>() {

            // isComment
            public boolean isMethod() {
                return true;
            }

            // isComment
            public Object isMethod() {
                throw new NoSuchElementException();
            }

            // isComment
            public void isMethod() {
                throw new UnsupportedOperationException();
            }
        };

        private static final Iterable<Object> isVariable = new Iterable<Object>() {

            // isComment
            public Iterator<Object> isMethod() {
                return isNameExpr;
            }
        };

        @SuppressWarnings("isStringConstant")
        static <T> Iterable<T> isMethod() {
            return (Iterable<T>) isNameExpr;
        }
    }
}
